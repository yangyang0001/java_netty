---------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------- 第1章 简介 -----------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
IO与CPU执行时间的比较: 事实证明 IO执行时间比CPU执行时间要慢得多

CPU执行效率已经不是瓶颈:
    操作系统喜欢整卡车地运来数据, java.io 类则喜欢一铲子一铲子 地加工数, 有了 NIO 就可以轻松地把一卡车数据备份到您能直接使用的地方(ByteBuffer 对象)

基础概念:(非常重要, 贯穿整个NIO的学习)
    缓冲区操作:
        任何的IO操作都是对缓冲区的操作, 缓冲区的出现是解决数据交互双方读取数据速度不一致而提出的!
        输入操作: 往缓冲区中往内读入数据
        输出操作: 从缓冲区中往外写出数据

    内核空间和用户空间
        内核空间: 操作系统所在空间就是内核空间, 这部分空间的代码和硬件可以直接交互, 也叫特权空间
        用户空间: 这部分空间的代码不能直接和硬件直接交互, 没有特定权限, 举例: JVM只是这个空间中一个进程而已!

    发散和汇聚:
        发散: 读入的时候是将内核空间缓冲区中的数据 发散到 用户空间的缓冲区的过程
        汇聚: 写出的时候是将用户空间缓冲区中的数据 汇聚到 内核空间的缓冲区的过程

    虚拟内存:
        硬盘中开辟一块区域, 这块区域通过相应的虚拟技术, 使这块区域达到和使用真实的物理内存一致的效果

    文件IO
        内存映射和文件系统

    流IO:
        基于字节或字符流的IO


---------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------- 第2章 缓冲区 ---------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
缓冲区 Buffer
    mark 属性     : 一个备忘位置
    position 属性 : 开始读或者开始写的位置
    limit 属性    : 能够读或者能够写的上限位置
    capacity 属性 : 最大容量

    缓冲区的翻转方法: flip() 具体跟踪源代码

        /**
         * 翻转这个缓冲区。
         * Flips this buffer.
         *
         * 将限制设置为当前位置，然后将位置设置为零。即 limit = position
         * The limit is set to the current position and then the position is set to zero.
         *
         * 如果定义了标记，则将其丢弃。
         * If the mark is defined then it is discarded.
         *
         * 在一系列通道读取或 put 操作之后，调用此方法以准备一系列通道写入或相关的 get 操作。此方法的作用: put 后要准备 get 时使用!
         * <p> After a sequence of channel-read or <i>put</i> operations, invoke this method to prepare for a sequence of channel-write or relative <i>get</i> operations.
         *
         *
         * 具体用法如下:
         * For example:
         *
         * <blockquote><pre>
         * buf.put(magic);    // Prepend header
         * in.read(buf);      // Read data into rest of buffer
         * buf.flip();        // Flip buffer
         * out.write(buf);    // Write header + data to channel</pre></blockquote>
         *
         * 在将数据从一处传输到另一处时，此方法通常与 {@link java.nio.ByteBuffer#compact compact} 方法结合使用。
         * <p> This method is often used in conjunction with the {@link java.nio.ByteBuffer#compact compact} method when transferring data from one place to another.  </p>
         *
         * @return  This buffer
         */
        public final Buffer flip() {
            limit = position;
            position = 0;
            mark = -1;
            return this;
        }

    缓冲区压缩 compact() 方法, 此方法是将 已经读取过的元素清除, 然后将后面的未读取的元素复制到开头, 且后面的元素不删除(特别重要)

    缓冲区标记 mark() 无使用价值, 如果使用

    缓冲区重置 reset() 无使用价值

    缓冲区的比较 compareTo() 没有实用价值, 这种是对剩余元素的比较: 即用 mark, position, limit 限定剩余可用元素

    缓冲区批量移动 读取数据 和 写入数据

缓冲区的创建
    IntBuffer, DoubleBuffer, ShortBuffer, LongBuffer, FloatBuffer, ByteBuffer, CharBuffer, MappedByteBuffer

复制缓冲区
    1、复制缓冲区会创建一个新的 Buffer 对象, 但不会复制数据 类似于引用传递, 多个引用共享一块真正的数据区!
    2、任何一块引用来修改这块数据区, 对所有的引用都是透明的!

ByteBuffer
    高端字节顺序: ByteOrder.BIG_ENDIAN
    低端字节顺序: ByteOrder.LITTLE_ENDIAN

---------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------- 第3章 通道 -----------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
IO分为两大类: 文件IO 和 流IO

Channel: 看做传输的管道, 分为两大类 File管道 和 Socket管道; Socket管道又有常见的类: SocketChannel, ServerSocketChannel, DatagramChannel

ByteChannel 和 ReadableByteChannel, WriteableByteChannel

Scatter/Gather: 发散/汇聚, 针对多个不同的 Buffer 看作一个的操作!

文件通道: FileChannel
    文件锁定: 锁与文件关联，而不是与通道关联, 我们使用锁来判优外部进程, 而不是判优同一个 Java 虚拟机上的线程

内存映射文件:
    用户空间 和 内核空间 共享一块 物理内存(MappedByteBuffer) 这块内存 和 磁盘之间建立 映射的关系!

Socket 通道:
    SocketChannel, ServerSocketChannel, DatagramChannel
    ServerSocketChannel 从不负责读写功能, 只是用来接受或创建新的Socket通道

Pipe 管道: 环回测试使用的两种 SinkChannel 写出使用, SourceChannel 读入使用!

---------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------- 第四4章 选择器 -----------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
选择器 Selector, 可选择通道 SelectableChannel, 选择键: SelectionKey

使用选择器
    选择器中包含三种键的集合
        已经注册的选择键集合    keys()
        已准备好的选择键集合    selectKeys()
        已经注销的选择键集合    cancel(), 新版本的API中已经没有这个了, 它也是已经注册键集合的子集!



















