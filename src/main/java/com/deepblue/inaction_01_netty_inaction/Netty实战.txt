---------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------- 第1章 Netty 异步和事件驱动 ------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
本章主要是了解Netty是啥? Netty的核心组成部件!

Netty的核心组件:
    Channel: 数据输入和输出通过的载体, 类似于网略原理中的链路或隧道技术!

    回调: 一种方法; Netty内部使用回调的方式处理事件, 当一个事件发生时, 必然会有一个回调函数被调用!

    Future: 异步操作结果站位符的作用, 在JUC中的它是一种异步结果的占位符, 往往通过阻塞来获取结果!
            在Netty中提供了 ChannelFuture 来处理所有出站结果, 每一个出站I/O操作都对应一个 ChannelFuture!
            变相的看 Future 或 ChannelFuture 是 出站事件的 回调！

    事件和ChannelHandler:
        事件: Netty 是网络编程框架, 网络从建立链接到释放链接的过程中所有动作都可以视为事件!
        ChannelHandler: 是处理 Channel 上的 事件处理器 或 回调处理器!


----------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------- 第2章 第一款 Netty 应用程序 -----------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------
本章先跟着做, 至于为什么这样做后续文章中继续研究!


----------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------- 第3章 Netty 中的组件和设计 -----------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------
Channel、EventLoop、ChannelFuture
    对标网络中的组件和应用
        Channel         -----   Socket
        EventLoop       -----   控制流, 并发, 多线程处理
        ChannelFuture   -----   异步通知

    Channel 接口: 对应的常用的方法: bind(), connect(), read(), write()

    EventLoop 接口

    ChannelFuture 接口: 因为 Netty 中的 I/O 处理都是异步的操作, 因此这里提出了 Future 和 ChannelFuture 的概念!

ChannelHandler 和 ChannelPipeline
    ChannelHandler接口 业务逻辑容器或处理器, ChannelHandler 被添加到 ChannelHandlerPipeline 中时会有一个 ChannelHandlerContext, 它绑定了 ChannelHandler 和 ChannelHandlerPipeline 的关系!

    Netty 写出数据的方式有两种:
        第一种: 通过 Channel 往外写数据; 这种方式导致消息从 ChannelPipeline 的尾部开始流动!
        第二种: 通过 ChannelHandlerContext 往外写数据; 这种方式导致消息从 ChannelPipeline 中的下一个 ChannelHandler 开始流动!


----------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------- 第4章 传输 ----------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------
NIO: 原生jdk中使用 selector 选择器处理事件

Epoll: Linux 系统下的非阻塞传输处理

OIO: 原生jdk中的 ServerSocket.accept()

Local: 同一个JVM中的本地传输

Embedded传输


















